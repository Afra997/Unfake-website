-- Supabase schema for UNFAKE
-- Run this in the Supabase SQL editor

-- Enable UUID if needed (usually enabled)
-- create extension if not exists "uuid-ossp";

-- Auth users are in auth.users; we'll store profiles in public.profiles if needed
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  full_name text,
  role text not null default 'user',
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

create table if not exists public.posts (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) on delete set null,
  title text not null,
  source text,
  description text,
  status text not null default 'pending',
  admin_reason text,
  created_at timestamp with time zone default now()
);

-- RLS
alter table public.profiles enable row level security;
alter table public.posts enable row level security;

-- Policies for profiles
create policy if not exists profiles_select_self on public.profiles
for select using ( auth.uid() = id );

create policy if not exists profiles_insert_own on public.profiles
for insert with check ( auth.uid() = id );

create policy if not exists profiles_update_self on public.profiles
for update using ( auth.uid() = id );

-- Policies for posts
-- Anyone authenticated can read posts
create policy if not exists posts_select_all on public.posts
for select using ( true );

-- Only authenticated users can insert, user_id must equal auth.uid()
create policy if not exists posts_insert_owner on public.posts
for insert with check ( user_id = auth.uid() );

-- Owners can update or delete their own pending posts
create policy if not exists posts_update_owner on public.posts
for update using ( user_id = auth.uid() );

create policy if not exists posts_delete_owner on public.posts
for delete using ( user_id = auth.uid() );

-- Optional: admins can update status and admin_reason
-- Create a Postgres function to detect admin via profiles.role
create or replace function public.is_admin(uid uuid)
returns boolean language sql stable as $$
  select exists (
    select 1 from public.profiles p where p.id = uid and p.role = 'admin'
  );
$$;

create policy if not exists posts_update_admin on public.posts
for update using ( public.is_admin(auth.uid()) );

-- Triggers to keep profiles in sync with auth metadata (optional)
create or replace function public.handle_new_user()
returns trigger language plpgsql security definer as $$
begin
  insert into public.profiles (id, full_name, role)
  values (new.id, coalesce(new.raw_user_meta_data->>'full_name', null), coalesce(new.raw_user_meta_data->>'role', 'user'))
  on conflict (id) do update set
    full_name = excluded.full_name,
    role = excluded.role,
    updated_at = now();
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function public.handle_new_user();

